
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gallery/10-utility/rng_speed.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_gallery_10-utility_rng_speed.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gallery_10-utility_rng_speed.py:


PRNG Speed
==========

Benchmarking the speed of various numpy pseudorandom number generators

.. GENERATED FROM PYTHON SOURCE LINES 7-21

.. code-block:: Python


    from timeit import timeit

    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    import seaborn as sns
    from numba import njit

    import mirage as mr

    n = 4096**2  # the number of pixels in our CCD image
    mus = np.random.randint(100, 100000, size=n).reshape(-1, 16)








.. GENERATED FROM PYTHON SOURCE LINES 22-23

Poisson PRNG

.. GENERATED FROM PYTHON SOURCE LINES 23-58

.. code-block:: Python


    names = ['MT19937', 'MT19937', 'PCG64', 'PCG64DXSM', 'Philox', 'SFC64']
    gens = [np.random.Generator(getattr(np.random, n)()).poisson for n in names]
    gens.append(mr.multithreaded_poisson)
    names.append('SFC64 8 threads')

    data = {'dt': [], 'name': []}
    for i, (gen, name) in enumerate(zip(gens, names)):
        mr.tic()
        samples = gen(mus)
        dt = mr.toc(return_elapsed_seconds=True)
        if i > 0:
            data['dt'].append(dt)
            data['name'].append(name)


    g = sns.catplot(
        data=pd.DataFrame(data),
        kind='bar',
        x='name',
        y='dt',
        errorbar='sd',
        alpha=0.6,
        height=6,
    )
    g.despine(left=True)
    g.set_axis_labels('', 'Time to sample image [s]')
    g.legend.set_title('')
    plt.title('Poisson sampling comparison')
    plt.grid()
    g.despine(left=True)
    plt.tight_layout()
    plt.show()





.. image-sg:: /gallery/10-utility/images/sphx_glr_rng_speed_001.png
   :alt: Poisson sampling comparison
   :srcset: /gallery/10-utility/images/sphx_glr_rng_speed_001.png, /gallery/10-utility/images/sphx_glr_rng_speed_001_2_00x.png 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 59-60

Gaussian PRNG

.. GENERATED FROM PYTHON SOURCE LINES 60-94

.. code-block:: Python

    mus = np.random.randn(n).reshape(-1, 16)
    sigmas = np.abs(np.random.randn(n).reshape(-1, 16))

    names = ['MT19937', 'MT19937', 'PCG64', 'PCG64DXSM', 'Philox', 'SFC64']
    gens = [np.random.Generator(getattr(np.random, n)()).normal for n in names]
    gens.append(mr.multithreaded_gaussian)
    names.append('SFC64 8 threads')

    data = {'dt': [], 'name': []}
    for i, (gen, name) in enumerate(zip(gens, names)):
        mr.tic()
        samples = gen(mus, sigmas)
        dt = mr.toc(return_elapsed_seconds=True)
        if i > 0:
            data['dt'].append(dt)
            data['name'].append(name)

    g = sns.catplot(
        data=pd.DataFrame(data),
        kind='bar',
        x='name',
        y='dt',
        errorbar='sd',
        alpha=0.6,
        height=6,
    )
    g.set_axis_labels('', 'Time to sample image [s]')
    g.legend.set_title('')
    plt.title('Gaussian sampling comparison')
    plt.grid()
    g.despine(left=True)
    plt.tight_layout()
    plt.show()




.. image-sg:: /gallery/10-utility/images/sphx_glr_rng_speed_002.png
   :alt: Gaussian sampling comparison
   :srcset: /gallery/10-utility/images/sphx_glr_rng_speed_002.png, /gallery/10-utility/images/sphx_glr_rng_speed_002_2_00x.png 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 95-96

Numba for sampling normals faster

.. GENERATED FROM PYTHON SOURCE LINES 96-144

.. code-block:: Python


    bit_gen = np.random.SFC64()
    next_d = bit_gen.cffi.next_double
    state_addr = bit_gen.cffi.state_address


    @njit
    def normals_numba(n, state):
        out = np.empty(n)
        for i in range((n + 1) // 2):
            x1 = 2.0 * next_d(state) - 1.0
            x2 = 2.0 * next_d(state) - 1.0
            r2 = x1 * x1 + x2 * x2
            while r2 >= 1.0 or r2 == 0.0:
                x1 = 2.0 * next_d(state) - 1.0
                x2 = 2.0 * next_d(state) - 1.0
                r2 = x1 * x1 + x2 * x2
            f = np.sqrt(-2.0 * np.log(r2) / r2)
            out[2 * i] = f * x1
            if 2 * i + 1 < n:
                out[2 * i + 1] = f * x2
        return out


    n = 4096**2


    def numbacall():
        return normals_numba(n, state_addr)


    rg = np.random.Generator(bit_gen)


    def numpycall():
        return rg.normal(size=n)


    # Check that the functions work
    r1 = numbacall()
    r2 = numpycall()
    assert r1.shape == (n,)
    assert r1.shape == r2.shape

    t1 = timeit(numbacall, number=3)
    print(f'{t1:.2f} secs for {n} PCG64 (Numba/SFC64) gaussian randoms')
    t2 = timeit(numpycall, number=3)
    print(f'{t2:.2f} secs for {n} PCG64 (NumPy/SFC64) gaussian randoms')




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    0.79 secs for 16777216 PCG64 (Numba/SFC64) gaussian randoms
    0.24 secs for 16777216 PCG64 (NumPy/SFC64) gaussian randoms





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 10.740 seconds)


.. _sphx_glr_download_gallery_10-utility_rng_speed.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: rng_speed.ipynb <rng_speed.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: rng_speed.py <rng_speed.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: rng_speed.zip <rng_speed.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
