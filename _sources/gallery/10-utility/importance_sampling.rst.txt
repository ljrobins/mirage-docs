
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gallery/10-utility/importance_sampling.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_gallery_10-utility_importance_sampling.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gallery_10-utility_importance_sampling.py:


Importance Sampling
===================
Reducing the variance of Monte Carlo integration

.. GENERATED FROM PYTHON SOURCE LINES 6-11

.. code-block:: Python


    import matplotlib.pyplot as plt
    import numpy as np
    import sympy as sp








.. GENERATED FROM PYTHON SOURCE LINES 12-13

Let's say we want to estimate the integral of an unknown function :math:`f(x)`

.. GENERATED FROM PYTHON SOURCE LINES 13-25

.. code-block:: Python

    x = sp.symbols('x')
    f_symbolic = sp.sin(np.pi * x)
    bounds = (0, 1)
    f = sp.lambdify(x, f_symbolic)
    xs = np.linspace(*bounds, 1000)

    plt.plot(xs, f(xs))
    plt.grid()
    plt.title('f(x)')
    plt.xlabel('x')
    plt.show()




.. image-sg:: /gallery/10-utility/images/sphx_glr_importance_sampling_001.png
   :alt: f(x)
   :srcset: /gallery/10-utility/images/sphx_glr_importance_sampling_001.png, /gallery/10-utility/images/sphx_glr_importance_sampling_001_2_00x.png 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 26-27

We can analytically compute the integral of this function

.. GENERATED FROM PYTHON SOURCE LINES 27-30

.. code-block:: Python

    int_symbolic = sp.integrate(f_symbolic, (x, 0, 1))
    print(f'The analytic integral is {int_symbolic:.4f}')





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    The analytic integral is 0.6366




.. GENERATED FROM PYTHON SOURCE LINES 31-32

A naive attempt at Monte Carlo integration would be to uniformly take samples of the function over the integral and average them

.. GENERATED FROM PYTHON SOURCE LINES 32-41

.. code-block:: Python

    n = 10  # number of samples
    f_of_x_naive = f(np.random.rand(n))
    int_naive = f_of_x_naive.sum() / n
    percent_error_naive = (int_naive - int_symbolic) / int_symbolic * 100

    print(
        f'The naive Monte Carlo integral is {int_naive:.4f}, {percent_error_naive:.2f}% error'
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    The naive Monte Carlo integral is 0.7454, 17.09% error




.. GENERATED FROM PYTHON SOURCE LINES 42-43

The fundamental idea of importance sampling is that our Monte Carlo result will be better if we take samples from a distribution that looks like the true function, dividing each sample by its pdf likelihood. To accomplish this, let's select a pdf that might help

.. GENERATED FROM PYTHON SOURCE LINES 43-61

.. code-block:: Python


    from scipy.stats.sampling import TransformedDensityRejection


    class NewPdf:
        def pdf(self, x: float) -> float:
            # Note that this is slightly
            return -6 * x**2 + 6 * x

        def dpdf(self, x: float) -> float:
            return -12 * x + 6


    dist = NewPdf()
    pdf = TransformedDensityRejection(
        dist, random_state=np.random.default_rng(), domain=[0, 1]
    )








.. GENERATED FROM PYTHON SOURCE LINES 62-63

Let's try Monte Carlo integration again with the new pdf

.. GENERATED FROM PYTHON SOURCE LINES 63-72

.. code-block:: Python


    xs_sample = pdf.rvs(n)
    int_importance = (f(xs_sample) / dist.pdf(xs_sample)).sum() / n
    percent_error_importance = (int_importance - int_symbolic) / int_symbolic * 100

    print(
        f'The importance sampled integral is {int_importance:.4f}, {percent_error_importance:.2f}% error'
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    The importance sampled integral is 0.6343, -0.36% error




.. GENERATED FROM PYTHON SOURCE LINES 73-74

Let's take a look at the points we sampled

.. GENERATED FROM PYTHON SOURCE LINES 74-85

.. code-block:: Python


    true_pdf = f(xs) / int_symbolic
    plt.figure()
    plt.plot(xs, true_pdf)
    plt.plot(xs, dist.pdf(xs))
    plt.scatter(xs_sample, 0 * xs_sample, s=5, alpha=0.2)
    plt.grid()
    plt.title('probability')
    plt.xlabel('x')
    plt.legend(['true pdf', 'approximate pdf', 'samples'])
    plt.show()



.. image-sg:: /gallery/10-utility/images/sphx_glr_importance_sampling_002.png
   :alt: probability
   :srcset: /gallery/10-utility/images/sphx_glr_importance_sampling_002.png, /gallery/10-utility/images/sphx_glr_importance_sampling_002_2_00x.png 2.00x
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 2.740 seconds)


.. _sphx_glr_download_gallery_10-utility_importance_sampling.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: importance_sampling.ipynb <importance_sampling.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: importance_sampling.py <importance_sampling.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
